הוסטל - Hostel
	מטרה: להבין האם ארכיטקטורה של angular elements מהווה אלטרנטיבה לגיטמית לארכיטקטורה של iframes.
	מטרת משנה: ללמוד נושאים מתקדמים באנגולר, ליישם אותם ולהבין האם הם מתאימים לפרוייקט הזה או לפרוייקטים אחרים.

החלק המרכזי הוא hostel עצמו, מערכת המאפשרת לטעון לתוכה angular elements בצורה דינמית, בתצורות שונות (tab, top-bar וכו'), כרגע אני מתרכז רק בtabים.
hostel היא לא אפליקציה מורכבת יותר מדי, יש שימוש בסיפרייה שעושה את החיים די קלים (angular-extension/elments).
	יש json בו רשומים כל הטאבים שצריכים להטען למערכת, עבור כל טאב יש את השדות:
		1. שם - יוצג ברשימת הטאבים.
		2. אייקון - יוצג ברשימת הטאבים.
		3. תגית - תגית הhtml שאליה יטען הangular element.
		4. מקור - url שממנו מייבאים את הjs המקומפל של הangular element.
	הספרייה מקבלת את התגית והמקור ומייבאת את האלמנט רק כשהוא צריך להתרנדר למסך (lazy dynamic).

לצורך הלימוד, הכנתי שישה טאבים שיכילו שש אפליקציות שונות, בכל אפליקציה אני בודק פונקציונליות אחרת אל מול הhostel.

	1. מלך האריות:
		מטרה: שימוש בסרביסים כלליים מתוך אלמנט
	הסרביסים שאותם אני רוצה לבדוק:
		1. toaster - הודעה לגבי הצלחה/שגיאה/אזהרה/מידע לגבי פעולה שנעשתה, ההודעה תפתח מחוץ לאלמנט בצד השמאלי העליון של המסך.
		2. notifications - שליחת מידע לגבי פעולה שנעשתה לשרת העדכונים.
		3. logger - שליחת לוג של פעולה שנעשתה לשרת הלוגים.
		4. כנראה יש עוד ששכחתי
		מסקנות:
			1. אין צורך שכל האפליקציות ישתמשו באותו מופע של הservice בגלל שהserviceים האלה הם stateless, וככה הם אמורים להיות.
			2. הservicים האלה יהיו בספרייה כדי שלא כל אפליקציה תממש אותם בנפרד ובכדי לשמור על api אחיד מול הhostel.
		נושאים ללמוד:
			1. שימוש בעץ של angular material כולל הבנה טובה של data-source, יכול לשמש אותנו.
			2. פיתוח ופריסה של ספרייה באנגולר.
		התקדמות:
			מימשתי את toaster כservice באפליקציה עצמה, צריך להוציא לספריה.
	
	2. צעצוע של סיפור:
		מטרה: פתיחת פאנל / דיאלוג / iframe או כל חלון נפתח אחר מתוך האלמנט אל תוך מרכז המסך.
		עקרונות:
			1. שמירה על אחידות בנראות של החלונות הנפתחים (שורת הכותרת למעלה, ושורת הכפתורים למטה).
			2. להמנע מכפל קוד במימוש.
			3. לאפשר כמה שיותר חופש פעולה למשתמשים בשירות.
			4. לאפשר פונקציונליות רחבה כולל: סגירה, מזעור, מסך מלא, שינוי גודל, גרירה, מניעת פתיחה כפולה, מניעת חלונות אחרים ועוד.
		מסקנות: 
			1. מכיוון שהמערכת הפותחת היא זו שיוצרת את החלון הנפתח, כשמזריקים service לתוך החלון הנפתח הוא יהיה אותו מופע כמו במערכת הפותחת והוא יכול להיות גם stateful.
			2. גם השירות הזה יהיה בספרייה.
		נושאים ללמוד:
			1. bitmask - שימוש בenum בחזקות של 2 בכדי להמנע מconfig עם הרבה properties בוליאנים.
			2. שימוש בoverlay של angular cdk, המאפשר ליצור פיסת ui במסך כך שניתן לרנדר לתוכה קומפוננטה.
			3. שימוש בInjectionToken - מאפשר להזריק ערכים לתוך מנגנון הDependency Injection של אנגולר להעברת מידע בקלות בין המערכת הפותחת לחלון הנפתח.
		התקדמות: פתיחת פאנל, דיאלוג וiframe, עם פונקציונליות של סגירה וגרירה.

	3. סיפורי נרניה:
		מטרה: בדיקת הפונקציונליות של input/output בין hostel לאלמנט, ווידוא מנגנון Change Detection
	כנראה לא נשתמש בפונקציונליות הזאת עבור המערכת שלנו, אז עיקר המאמץ פה הוא ללמוד על WebComponents בכללי.
	input/output בweb components זה לא פשוט כמו בקומפננטה של אנגולר, אבל זה אפשרי.
	בangular elements השימוש הוא פחות או יותר כמו קומפוננטה כי אנגולר עוטפים הכול מאחורי הקלעי.
	מסתבר שיש בעייתיות ב change detection כשמתמשים בangular elements, בגלל שיש 2 zone שונים, אבל היא פתירה. צריך להחליט על הפתרון המתאים לנו.
		מסקנות:
			1. (לא הוחלט) להשתמש באותו zone \ לא להשתמש ב zone בכלל באלמנט. לא הצלחתי לשחזר את הבעייתיות, נראה שעובד כרגיל
			2. אפשר להשתמש בinput כדי להעביר מידע שמשותף לכל הטאבים, כמו למשל user וכו'.
		נושאים ללמוד: 
			1. ZoneJs וNgZone.
			2. events בין web components (המימוש של output).
			3. מה המשמעות של אפליקציית אנגולר ללא zone.
		התקדמות:
			אין פה יותר מדי מה לעשות

	4. מואנה:
		מטרה: שימוש בrouter בתוך angular element. שימוש בlazy loading ואיך זה בא לידי ביטוי.
	אני לא חושב שאמורה להיות בעיה עם router, אבל כן ראיתי שיכולה להיות כי האלמנטים "רבים" על הroute.
	הכוונה בlazy loading היא שחלקים באפליקציה (מודולים מסויימים) יהיו lazy modules - נטענים רק כשצריך אותם.
		נושאים ללמוד:
			1. העמקה בangular router.
			2. השוואה ל ui-router.
			3. הבנה של lazy modules, והאם זה אפשרי בתוך angular elements.
		מסקנות:
			1. (לא הוחלט) ניתוב בתוך אלמנט אפשרי / לא אפשרי.
			2. (לא הוחלט) ניתוב אחר צריך להיות פשוט אלמנט אחר?
		התקדמות:

	5. עידן הקרח:
		מטרה: בדיקת התכנות עבור אפליקציות בגרסאות קודמות של אנגולר, בכלל angularJS.
	קראתי שלא אמורה להיות בעיה בנושא, צריך להבין איך עושים את זה.
		נושאים ללמוד:
			1. web components באנגולר js.
		מסקנות:
			1. (לא הוחלט) לפתוח כאלמנט או כiframe.
		התקדמות:

	6. משפחת סופר-על:
		מטרה: כרגע ללא מטרה, כנראה אני אמצא בהמשך
		נושאים ללמוד:
		מסקנות:
		התקדמות

נושאים כללים הדורשים התייחסות:
	1. תאימות גרסאות בין אלמנטים שונים
		אם שני אלמנטים הם באותו גרסא, הם יכולים להשתמש באותם קבצי אנגולר שמתקמפלים בנפרד ובכך לחסוך מקום בbundle.
		כמובן שלא נוכל להסתדר רק עם גרסה אחת כי זה יוצר תלות גדולה מדי, צריך לבדוק האם אפשר לתאם לגרסאות מייג'ור שלא דורשות שבירת api.
		כלומר אם יש 2 אפליקציות באנגולר 6, להכריח אותם להתאים את התלויות לאותו גרסה (6.2.2 לדוגמא) כך שיוכלו להשתמש באותם קבצי אנגולר.
		צריך דרך לנהל את הגרסאות השונות.
		במקרה הגרוע, כל אחד טוען לעצמו את האנגולר שלו, בדיוק כמו שקורה עכשיו עם iframes.
		
		עוד נקודה בנושא הזה, עקרון דומה אפשר לעשות על importים נפוצים כמו angular material.
		בגלל שהאלמנטים על אותו dom, הם יכולים להשתמש באותו import למרות שהם אפליקציות שונות.
		עלול ליצור תלות בין האפליקציות, גם פה צריך לחשוב איך לנהל את זה.

	2. מיסוך עיצוב
		בגלל שכל האלמנטים נמצאים על אותו dom, יכול להווצר דריסת עיצוב בין אלמנט לאלמנט - רע.
		בגדול, המיסוך של אנגולר מספיק בכדי למנוע את הדריסה הזאת.
		אבל אנשים משתמשים בng-deep שמונע את המיסוך הזה, וכך אפשר לדרוס עיצוב של אלמנטים אחרים - בעיקר בשימוש בangular material.
		יש פתרונות לבעיה הזאת וצריך להחליט על הפתרון המתאים ביותר
			1. הפתרון הפשוט, להוסיף class ייחודי לאפליקציה, ובכל מקום שמשתמשים בng-deep, להגדיר את בסלקטור רק אלמנטים שתחת הclass הזה.
			2. הפתרון הנכון אבל לא ריאלי, פשוט לא להשתמש בng-deep. זה anti-pattern. אבל כמובן שיש מצבים שאין ברירה.
			3. לדרוס את העיצוב בקומפוננטה (בעזרת ViewChild/ren), או יותר עדיף בdirective.

	3. סביבת פיתוח
		צריך להבין איך אמורה להיות סביבת הפיתוח בארכיטקטורה הזאת.
		כמובן שכל אפליקציה יכולה לפתוח את עצמה בפורט 4200 כמו אפליקציית אנגולר רגילה, אבל היא לא תהיה בתוך הhostel.
		כדי להיות בתוך הhostel, כרגע לפחות, היא צריכה לעשות build, דבר שיקשה מאוד על תהליך הפיתוח. צריך לחשוב על פתרון.

	4. תיעוד
		נקודה שהייתה חסרה בארכיטקטורה הקודמת. 
		בארכיטקטורה הזאת, הנקודה הזאת יותר קריטית בגלל שהיא כוללת נושאים קצת יותר מתקדמים.
		הסבר מפורט על כל התהליך ומה קורה מאחורי הקלעים.
		מתכון קצר ומהיר איך ליצור אלמנט חדש ואיך להפוך אפליקציה קיימת לאלמנט.

	5. תאימות לגרסאות דפדפן ישנות
		אפליקציות נוצרות עם polyfills כדי לאפשר תאימות גם לדפדפנים ישנים.
		בweb components הנושא משמעותי יותר כיוון שהארכיטקטורה בנויה על הדפדפן ועל הדפדפן לתמוך ברעיון הזה.
		למזלנו, הדפדפנים היחידים שלא תומכים (עדיין) בweb components הם IE ו EDGE (איכשהו מייקרוסופט נשארה מאחורה בנושא הזה)
		אבל כרום בכל הגרסאות אמור לעבוד כרגיל, ולכן אני חושב שאפשר לוותר על הpolyfills האלה.
		זה ייקצר ויפשט את תהליך הפיתוח (build כרגע נעשה בשני גרסאות, אחת לes2015 ואחת es5, אני חושב שאפשר להסתפק בes2015).
		אני קצת חסר ידע בנושא הזה, אז יכול להיות שאני טועה. צריך לשאול מישהו שמבין בזה יותר.

היו לי עוד נושאים חשובים אבל שכחתי, אני אזכר בהם ואוסיף.